import os
import numpy as np
from collections import Counter

CLASS_LABELS = {
    "wall": 0,
    "door": 1,
    "window": 2,
}

def z_rotation(angle):
    """
    Convert angle around z-axis to rotation matrix
    """
    s = np.sin(angle)
    c = np.cos(angle)
    rot_matrix = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])
    return rot_matrix

def _compute_counts(boxes):
    class_counts = Counter([b["class"] for b in boxes])
    print("Scene contains:")
    for class_name, count in class_counts.items():
        print(f"  {class_name}: {count}")

def language_to_bboxes(entities):
    """
    Converts language entities to corresponding bounding boxes
    """
    box_definitions = []
    lookup = {}
    for command, params in entities:
        if command == "make_wall":
            identifier = int(params["id"])
            height = params["height"]
            thickness = params["thickness"]
            corner_a = np.array([params["a_x"], params["a_y"], params["a_z"]])
            corner_b = np.array([params["b_x"], params["b_y"], params["b_z"]])
            length = np.linalg.norm(corner_a - corner_b)

            direction = corner_b - corner_a
            angle = np.arctan2(direction[1], direction[0])
            lookup[identifier] = {**params, "angle": angle}

            center = (corner_a + corner_b) * 0.5 + np.array([0, 0, 0.5 * height])
            scale = np.array([length, thickness, height])
            rotation = z_rotation(angle)
        elif command in {"make_door", "make_window"}:
            for key in ["wall_id", "wall0_id", "wall1_id"]:
                wall_id = params.get(key, None)
                if wall_id is not None and wall_id >= 0:
                    break
            if wall_id is None:
                continue
            wall = lookup.get(wall_id, None)
            if wall is None:
                continue
            identifier = int(params["id"])
            angle, thickness = wall["angle"], wall["thickness"]

            center = np.array(
                [
                    params["position_x"],
                    params["position_y"],
                    params["position_z"],
                ]
            )
            rotation = z_rotation(angle)
            scale = np.array([params["width"], thickness, params["height"]])
        else:
            print(f"Entity to box conversion not implemented for: cmd={command}")
            continue

        class_name = command[5:]  # remove "make_"
        class_label = CLASS_LABELS[command[5:]]
        identifier_label = f"{class_name}{identifier}"
        box = {
            "id": identifier_label,
            "cmd": command,
            "class": class_name,
            "label": class_label,
            "center": center,
            "rotation": rotation,
            "scale": scale,
        }
        box_definitions.append(box)
    _compute_counts(box_definitions)
    return box_definitions

def parse_scene_description(file_path):
    objects = []
    with open(file_path, 'r') as file:
        for line in file:
            parts = line.strip().split(', ')
            command = parts[0]
            params = {}
            for part in parts[1:]:
                key, value = part.split('=')
                params[key.strip()] = float(value.strip()) if '.' in value else int(value.strip())
            objects.append((command, params))
    return objects

def create_usda_header():
    return '''#usda 1.0
(
    doc = "Generated by Python script"
    metersPerUnit = 1
    upAxis = "Z"
)

def Xform "World" (
    kind = "assembly"
)
{
'''

def create_xform_prim(box):
    xform_prim = f'''
    def Xform "{box['id']}" (
        kind = "component"
    )
    {{
        matrix4d xformOp:transform = (
            ({box['rotation'][0][0]}, {box['rotation'][0][1]}, {box['rotation'][0][2]}, {box['center'][0]}),
            ({box['rotation'][1][0]}, {box['rotation'][1][1]}, {box['rotation'][1][2]}, {box['center'][1]}),
            ({box['rotation'][2][0]}, {box['rotation'][2][1]}, {box['rotation'][2][2]}, {box['center'][2]}),
            (0, 0, 0, 1)
        )
        uniform token[] xformOpOrder = ["xformOp:transform"]

        def Mesh "mesh" {{
            float3[] points = [
                ({-0.5 * box['scale'][0]}, {-0.5 * box['scale'][1]}, {-0.5 * box['scale'][2]}),
                ({0.5 * box['scale'][0]}, {-0.5 * box['scale'][1]}, {-0.5 * box['scale'][2]}),
                ({0.5 * box['scale'][0]}, {0.5 * box['scale'][1]}, {-0.5 * box['scale'][2]}),
                ({-0.5 * box['scale'][0]}, {0.5 * box['scale'][1]}, {-0.5 * box['scale'][2]}),
                ({-0.5 * box['scale'][0]}, {-0.5 * box['scale'][1]}, {0.5 * box['scale'][2]}),
                ({0.5 * box['scale'][0]}, {-0.5 * box['scale'][1]}, {0.5 * box['scale'][2]}),
                ({0.5 * box['scale'][0]}, {0.5 * box['scale'][1]}, {0.5 * box['scale'][2]}),
                ({-0.5 * box['scale'][0]}, {0.5 * box['scale'][1]}, {0.5 * box['scale'][2]})
            ]
            int[] faceVertexIndices = [0, 1, 2, 3, 4, 5, 6, 7]
            int[] faceVertexCounts = [4, 4, 4, 4, 4, 4]
            uniform token subdivisionScheme = "none"
        }}
    }}
'''
    return xform_prim


def convert_to_usda(boxes, output_file):
    with open(output_file, 'w') as file:
        file.write(create_usda_header())
        for box in boxes:
            file.write(create_xform_prim(box))
        file.write("}\n")

if __name__ == "__main__":
    input_file = "scene.txt"
    output_file = "scene.usda"

    if os.path.exists(input_file):
        entities = parse_scene_description(input_file)
        boxes = language_to_bboxes(entities)
        convert_to_usda(boxes, output_file)
        print(f"USDA file '{output_file}' created successfully.")
    else:
        print(f"Input file '{input_file}' does not exist.")
